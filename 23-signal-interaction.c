/**
 * При нажатии ctrl-C программа выведет сообщение и лишь на 5-й раз завершается
 */
#include <unistd.h>
#include <signal.h>
#include <errno.h>

//volatile - отключаем оптимизацию, чтобы переменная всегда читалась из памяти
// sig_atomic_t - гарантирует что чтение и запись переменной будет происходить
// в одну машинную команду
volatile sig_atomic_t n = 0;

const char message[] = "Press it again, I like it\n";

void handler(int s) {
    int save_errno = errno;

    // вставляем в начало обработчика снова переустановку диспозиции
    // чтобы на всякий случай избежать момента, когда ос переставит
    // наш обработчик на обработчик по умолчанию
    signal(SIGINT, handler);

    n++;

    // используем более низкоуровневую обертку для вывода, чтобы не было
    // буферизации потока
    write(1, message, sizeof(message) - 1);

    // это штука для обертки write'а нужна
    errno = save_errno;
}

int main() {
    signal(SIGINT, handler);

    //уменьшим паразитную нагрузку, воткнув в беск цикл
    // sleep чтобы программа просыпалась раз в секунду (можно и реже,
    // но одной секунды уже достаточно для того, чтобы паразитная
    // нагрузка была незаметной)
    // другая возможность - pause() - наша прога заснет до получения сигнала
    while(n < 5) pause();
    return 0;
}


