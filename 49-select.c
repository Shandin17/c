/**
* @description обработчик событий
 *      Позволяет обрабатывать события трех типов:
 *          - изменение состояния файлового дескриптора
 *          - истечение заданного колва времени с момента входа в вызов
 *          - получение процессом неигнорируемого сигнала
 * @args
 *      n - указывает количество значащих элементов в множествах изл ниже
 *          этот параметр надо установить равным max_d + 1, где
 *          max_d - максимальный номер дескриптора среди подлежащих обработке.
 *      readfds, writefds, exfds - обозначают МНОЖЕСТВА файловых дескрипторов, для которых
 *          нас интересует соответственно возможность немедленного чтения,
 *          возможность немедленной записи, наличие исключительной ситуации
 *      timeout - промежуток времени, спустя который следует вернуть управление,
 *          даже если никаких событий, связанных с дескрипторами, не произошло
 * @dev
 *      Объект "множество дескрипторов" задается переменной типа fd_set.
 *      Внутренняя реализация переменных этого типа для различных систем
 *      теоретически может оказаться разной, но проще всего ее представлять
 *      как битовую строку, где каждому дескриптору соответствует один бит.
 *      Для работы с переменными этого типа система предоставляет следующие макросы:
 *      FD_ZERO(fd_set *set) // очистить множество
 *      FD_CLR(int fd, fd_set *set); // убрать дескриптор из мн-ва
 *      FD_SET(int fd, fd_set *set); // добавить дескриптор к мн-ву
 *      FD_ISSET(int fd, fd_set *set); // входит ли дескр-р в мн-во?
 *
 *      В качестве любого из параметров (кроме первого) можно передать NULL.
 *      Вызов select(0 , NULL, NULL, NULL, NULL) эквивалентен вызову pause
 *      select(0 , NULL, NULL, NULL, timeout) эквивалентен sleep и usleep
 *
 * @return
 *     Вызов select возвращает управление в следующих случаях:
 *      1) произошла ошибка (указали несущ дескриптор). Вернет -1
 *      2) процесс получил обрабатываемый сигнал. Вернет -1
 *          отличить от ошибки можно по errno == EINTR
 *      3) истек тайм-аут, то есть с момента входа в вызов прошло больше времени
 *          чем указано в параметре timeout. Вернет 0
 *      4) на дескриптор из readfds пришли данные для чтения или запрос или возникла
 *          ситуация "конец файла" (это называют готовностью к чтению, хотя "чтение" в буквальном
 *          смысле подразумевается отнюдь не всегда, те же слушающие сокеты тому пример)
 *      5) дкскриптор из writefds готов к немедленной записи, то есть если применить к нему вызов
 *          write, send или еще какой-нибудь подобный, то он сможет записать НЕМЕДЛЕННО хоть сколько-нибудь
 *          данных (готовность к записи)
 *      6) на одном из дескрипторов из exfds возникла исключительная ситуация
 *      7) с одним из потоков данных, чьи дескрипторы включены во множества readfds, writefds или exfds
 *          случилась неприятность (возникла ошибка)
 *
 *      В последних четырех случаях вызов select возвращает количество дескрипторов, на которых
 *      произошли события, причем один дескриптор (если он входит в разные множества) может быть
 *      посчитан несколько раз.
 *      Все множества дескрипторов при этом перезаписываются: в них остаются только те дескрипторы,
 *      на которых что-то произошло (готовность, ошибка и т.д.)
 *
 *
*/
int select(int n, fd_set *readfds, fd_set *writefds, fd_set *exfds, struct timeval *timeout);
