Пишем обертку для системног овызова

по серьезничу напишем обертки для write и для возможного read

назовем наши обертки sys_write & sys_read

код ошибки (возможной) назовем sys_errno

Отметим, что реализации этих вызовов, как и вообще
любых системных вызовов, имеющих 3 32ух битных параметра, будут иметь одинаковую
систему команд. Отличаться будут только номером сист вызова

Создадим одно тело для несколтьких оберток.

создавать тело будет в соответствии с конвенцией CDECL: программа имеет право
портить только EAC, ECX и EDX регистры. 
Но мы вынуждены будем трогать еще EBP и EBX. Поэтому лишний раз обработаем их через стек
(засунем и вытащим)

кароче:
    - обертка будет представлять собой точку входа, которая помещает нужный номер сист вызова
в регистр EAX, а затем делает простой переход на общую реализацию
Реализация:
    - сохраняем старое знач EBP в стек фрейм
    - создаем новый стековый фрейм
    - помещаем туда старое знач EBX
    - извлекаем из стека параметры сист вызова
    - раскладываем их по регистрам EBX, ECX и EDX
    - передаем управление ядру
    - по возвращении выяснить не принадлежит ли возвра значение диапазону 
от 0xfffff000 до 0xffffffff (это все ошибки). 
    - Если ошибка - заносим в sys_errno и в EAX сунуть -1
    - если окей, то возвращаем управление вызывавшему, предварительно восстановив состояние
регистров и стека

nasm -f elf start.asm
nasm -f elf calls.asm
gcc -Wall -c without-lib.c
ld start.o calls.o without-lib.o -o without-lib
